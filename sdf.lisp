(in-package #:org.shirakumo.raster)

(deftype sdf ()
  '(function (single-float single-float) single-float))

(declaim (inline vlen))
(defun vlen (x y)
  (sqrt (+ (expt x 2) (expt y 2))))

(declaim (inline dot))
(defun dot (ax ay bx by)
  (+ (* ax bx) (* ay by)))

(declaim (inline clamp))
(defun clamp (x min max)
  (min max (max min x)))

(defun rectangle (x y w h &key corner-radii)
  (let ((x (coordinate x)) (y (coordinate y))
        (w (coordinate w)) (h (coordinate h)))
    (etypecase corner-radii
      (null
       ;; Basic aligned rec case
       (lambda (nx ny)
         (declare (type coordinate nx ny))
         (let ((dx (- (abs (- nx x)) w))
               (dy (- (abs (- ny y)) h)))
           (+ (min 0f0 (max dx dy))
              (sqrt (+ (expt (max dx 0f0) 2)
                       (expt (max dy 0f0) 2)))))))
      (T
       ;; Rounded rect case
       (let ((rtl (coordinate (elt corner-radii 0)))
             (rtr (coordinate (elt corner-radii 1)))
             (rbr (coordinate (elt corner-radii 2)))
             (rbl (coordinate (elt corner-radii 3))))
         (lambda (nx ny)
           (declare (type coordinate nx ny))
           (let* ((px (- nx x))
                  (py (- ny y))
                  (r (if (< 0 px)
                         (if (< 0 py) rtr rbr)
                         (if (< 0 py) rtl rbl)))
                  (qx (+ r (- (abs px) w)))
                  (qy (+ r (- (abs py) h))))
             (+ (min 0f0 (max qx qy))
                (sqrt (+ (expt (max qx 0f0) 2)
                         (expt (max qy 0f0) 2)))
                (- r)))))))))

(defun ellipse (x y w h &key (start 0) (end (* 2 PI)) (inner-radius 0.0))
  (let* ((x (coordinate x)) (y (coordinate y))
         (w (/ (coordinate w))) (h (/ (coordinate h)))
         (inner-radius (/ (coordinate inner-radius)))
         (start (coordinate start)) (end (coordinate end)))
    (cond ((and (<= inner-radius 0.0) (<= (* 2 PI) (- end start)))
           ;; Cicrle case
           (lambda (nx ny)
             (declare (type coordinate nx ny))
             (vlen (* (- nx x) w) (* (- ny y) h))))
          ((<= (* 2 PI) (- end start))
           ;; Ring case
           (lambda (nx ny)
             (declare (type coordinate nx ny))
             (let ((nx (- nx x))
                   (ny (- ny y)))
               (- (vlen (* nx w) (* ny h)) inner-radius))))
          (T
           ;; General pie ring case
           (let ((start (- start (/ PI 2)))
                 (aperture (* (abs (- end start)) 0.5)))
             (when (< end start)
               (decf start (+ (* 2 aperture) PI))
               (decf aperture PI))
             (let ((cx (sin aperture))
                   (cy (cos aperture)))
               (when (<= PI aperture)
                 (setf cx 0f0 cy -1f0))
               (let ((cstart (cos (+ aperture start)))
                     (sstart (sin (+ aperture start))))
                 (lambda (nx ny)
                   (declare (type coordinate nx ny))
                   (let* ((nx (- nx x)) (ny (- ny y))
                          (nx (abs (+ (* cstart nx) (- (* sstart ny)))))
                          (ny (+ (* sstart nx) (* cstart ny)))
                          (l (- (vlen nx ny) 0.5))
                          (n (clamp (dot nx ny cx cy) 0.0 0.5))
                          (m (vlen (- nx (* cx n)) (- ny (* cy n))))
                          (sdf (max l (* m (signum (- (* cy nx) (* cx ny)))))))
                     (- sdf inner-radius))))))))))

(defun line (ax ay bx by &key (thickness 1f0))
  (let* ((ax (coordinate ax)) (ay (coordinate ay))
         (bax (- (coordinate bx) ax)) (bay (- (coordinate by) ay))
         (len (+ (* bax bax) (* bay bay)))
         (thick (coordinate thickness)))
    (lambda (nx ny)
      (declare (type coordinate nx ny))
      (let* ((nax (- nx ax)) (nay (- ny ay))
             (h (min 1f0 (max 0f0 (/ (+ (* nax bax) (* nay bay)) len))))
             (lx (- nax (* h bax)))
             (ly (- nay (* h bay))))
        (- (sqrt (+ (* lx lx) (* ly ly))) thick)))))

(defun bezier (ax ay bx by &key (thickness 1f0))
  )

(defun polygon (points)
  (let* ((v (make-array (length points) :element-type 'single-float))
         (n (length v)))
    (map-into v #'coordinate points)
    (lambda (nx ny)
      (declare (type coordinate nx ny))
      (let ((d (+ (expt (- nx (aref v 0)) 2)
                  (expt (- ny (aref v 1)) 2)))
            (s 1f0))
        (loop for j = (* 2 (1- n)) then i
              for i from 0 below (* 2 n) by 2
              for ex = (- (aref v (+ 0 j)) (aref v (+ 0 i)))
              for ey = (- (aref v (+ 1 j)) (aref v (+ 1 i)))
              for wx = (- nx (aref v (+ 0 i)))
              for wy = (- ny (aref v (+ 1 i)))
              for tt = (clamp (/ (dot wx wy ex ey) (dot ex ey ex ey)) 0f0 1f0)
              for bx = (- wx (* ex tt))
              for by = (- wy (* ey tt))
              do (setf d (min d (dot bx by bx by)))
                 (let ((a (<= ny (aref v (+ 1 i))))
                       (b (< ny (aref v (+ 1 i))))
                       (c (< (* ey wx) (* ex wy))))
                   (when (or (and a b c) (not (or a b c)))
                     (setf s (- s)))))
        (* s (sqrt d))))))

(defun subtract (a b)
  (declare (type sdf a b))
  (lambda (x y)
    (declare (type coordinate x y))
    (max (funcall a x y)
         (- (funcall b x y)))))

(defun combine (a b)
  (declare (type sdf a b))
  (lambda (x y)
    (declare (type coordinate x y))
    (min (funcall a x y)
         (funcall b x y))))

(defun intersect (a b)
  (declare (type sdf a b))
  (lambda (x y)
    (declare (type coordinate x y))
    (let ((a (funcall a x y))
          (b (funcall b x y)))
      (max (min a b) (- (max a b))))))

(defun outline (sdf thickness)
  (declare (type sdf sdf))
  (let ((th (coordinate thickness)))
    (lambda (x y)
      (declare (type coordinate x y))
      (let ((v (funcall sdf x y)))
        (- (abs v) th)))))

(defun translate (sdf x y)
  (declare (type sdf sdf))
  (let ((x (coordinate x))
        (y (coordinate y)))
    (lambda (nx ny)
      (declare (type coordinate nx ny))
      (funcall sdf (- nx x) (- ny y)))))

(defun scale (sdf x y)
  (declare (type sdf sdf))
  (let ((x (coordinate x))
        (y (coordinate y)))
    (lambda (nx ny)
      (declare (type coordinate nx ny))
      (funcall sdf (* nx x) (* ny y)))))

(defun rotate (sdf angle)
  (declare (type sdf sdf))
  (let ((cos (cos (coordinate angle)))
        (sin (sin (coordinate angle))))
    (lambda (nx ny)
      (declare (type coordinate nx ny))
      (funcall sdf
               (+ (* nx cos) (* ny sin))
               (+ (* nx (- sin)) (* ny cos))))))

(defun skew (sdf x y)
  (declare (type sdf sdf))
  (let ((x (tan (coordinate x)))
        (y (tan (coordinate y))))
    (lambda (nx ny)
      (declare (type coordinate nx ny))
      (funcall sdf (+ nx (round (* ny y))) (+ ny (round (* nx x)))))))

(defun transform (sdf mat)
  (declare (type sdf sdf))
  (declare (type (simple-array single-float (6)) mat))
  (lambda (nx ny)
    (declare (type coordinate nx ny))
    (funcall sdf
             (round (+ (* (aref mat 0) nx) (* (aref mat 1) ny) (aref mat 2)))
             (round (+ (* (aref mat 3) nx) (* (aref mat 4) ny) (aref mat 5) )))))
