(in-package #:org.shirakumo.raster)

(deftype sdf ()
  '(function (index index) single-float))

(defun rectangle (x y w h)
  (let ((x (float x 0f0)) (y (float y 0f0))
        (w (float w 0f0)) (h (float h 0f0)))
    (lambda (nx ny)
      (declare (type index nx ny))
      (let ((dx (- (abs (- nx x)) w))
            (dy (- (abs (- ny y)) h)))
        (+ (min 0f0 (max dx dy))
           (sqrt (+ (expt (max dx 0f0) 2)
                    (expt (max dy 0f0) 2))))))))

(defun ellipse (x y w h)
  (let ((x (float x 0f0)) (y (float y 0f0))
        (w (/ 2f0 (float w 0f0))) (h (/ 2f0 (float h 0f0))))
    (lambda (nx ny)
      (declare (type index nx ny))
      (sqrt (+ (expt (* (- nx x) w) 2)
               (expt (* (- ny y) h) 2))))))

(defun subtract (a b)
  (declare (type sdf a b))
  (lambda (x y)
    (declare (type index x y))
    (max (funcall a x y)
         (- (funcall b x y)))))

(defun combine (a b)
  (declare (type sdf a b))
  (lambda (x y)
    (declare (type index x y))
    (min (funcall a x y)
         (funcall b x y))))

(defun intersect (a b)
  (declare (type sdf a b))
  (lambda (x y)
    (declare (type index x y))
    (let ((a (funcall a x y))
          (b (funcall b x y)))
      (max (min a b) (- (max a b))))))

(defun translate (sdf x y)
  (declare (type sdf sdf))
  (declare (type index x y))
  (lambda (nx ny)
    (declare (type index nx ny))
    (funcall sdf (- nx x) (- ny y))))

(defun scale (sdf x y)
  (declare (type sdf sdf))
  (declare (type single-float x y))
  (lambda (nx ny)
    (declare (type index nx ny))
    (funcall sdf (round (* nx x)) (round (* ny y)))))

(defun rotate (sdf angle)
  (declare (type sdf sdf))
  (let ((cos (cos (float angle 0f0)))
        (sin (sin (float angle 0f0))))
    (lambda (nx ny)
      (declare (type index nx ny))
      (funcall sdf (round (* nx cos)) (round (* ny sin))))))

(defun skew (sdf x y)
  (declare (type sdf sdf))
  (let ((x (tan (float x 0f0)))
        (y (tan (float y 0f0))))
    (lambda (nx ny)
      (declare (type index nx ny))
      (funcall sdf (+ nx (round (* ny y))) (+ ny (round (* nx x)))))))

(defun transform (sdf mat)
  (declare (type sdf sdf))
  (declare (type (simple-array single-float (6)) mat))
  (lambda (nx ny)
    (declare (type index nx ny))
    (funcall sdf
             (round (+ (* (aref mat 0) nx) (* (aref mat 1) ny) (aref mat 2)))
             (round (+ (* (aref mat 3) nx) (* (aref mat 4) ny) (aref mat 5) )))))
